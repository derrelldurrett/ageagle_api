# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

require 'cucumber/rails'

# Capybara defaults to CSS3 selectors rather than XPath.
# If you'd prefer to use XPath, just uncomment this line and adjust any
# selectors in your step definitions to use the XPath syntax.
# Capybara.default_selector = :xpath

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
ActionController::Base.allow_rescue = false

# This lenghty commented block serves to document the first effort to run headless tests under WSL.
# Configure Capybara
# Capybara.javascript_driver = :webkit
# Capybara::Webkit.configure do |capy_config|
#   # Enable debug mode. Prints a log of everything the driver is doing.
#   capy_config.debug = true
#
#   # By default, requests to outside domains (anything besides localhost) will
#   # result in a warning. Several methods allow you to change this behavior.
#
#   # Silently return an empty 200 response for any requests to unknown URLs.
#   capy_config.block_unknown_urls
#
#   # Allow pages to make requests to any URL without issuing a warning.
#   capy_config.allow_unknown_urls
#
#   # Allow a specific domain without issuing a warning.
#   capy_config.allow_url("example.com")
#
#   # Allow a specific URL and path without issuing a warning.
#   capy_config.allow_url("example.com/some/path")
#
#   # Wildcards are allowed in URL expressions.
#   capy_config.allow_url("*.example.com")
#
#   # Silently return an empty 200 response for any requests to the given URL.
#   capy_config.block_url("example.com")
#
#   # Timeout if requests take longer than 5 seconds
#   capy_config.timeout = 20
#
#   # Don't raise errors when SSL certificates can't be validated
#   capy_config.ignore_ssl_errors
#
#   # Don't load images
#   capy_config.skip_image_loading
#
#   # Use a proxy
#   capy_config.use_proxy(
#       host: "example.com",
#       port: 1234,
#       user: "proxy",
#       pass: "secret"
#   )
#
#   # Raise JavaScript errors as exceptions
#   capy_config.raise_javascript_errors = true
# end
#
# if Capybara.current_driver == :webkit
#   require 'headless'
#
#   headless = Headless.new
#   headless.start
# end

# This remaining block is what was used to try a different headless testing approach on WSL.
# Configure Capybara/Selenium
require "selenium/webdriver"
require 'webdrivers/chromedriver'

Capybara.javascript_driver = :headless_chrome
Webdrivers.logger.level = :DEBUG
Webdrivers::Chromedriver.required_version = '75.0.3770.140'
Selenium::WebDriver::Chrome.path = '/usr/bin/google-chrome'

Capybara.register_driver :chrome do |app|
  Capybara::Selenium::Driver.new(app, browser: :chrome)
end

Capybara.register_driver :headless_chrome do |app|
  capabilities = Selenium::WebDriver::Remote::Capabilities.chrome(
      chromeOptions: { args: %w(headless single-process no-gpu no-sandbox disable-setuid-sandbox disable-dev-shm-usage) } # disable-gpu proxy-server="direct://" proxy-bypass-list="*"
  )

  Capybara::Selenium::Driver.new app,
                                 browser: :chrome,
                                 desired_capabilities: capabilities
end
